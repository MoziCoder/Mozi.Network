<!DOCTYPE html>




<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>
            
    
        draft-cai-ssdp-v1-03
    

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            @media only screen
            and (min-width: 992px)
            and (max-width: 1199px) {
                body { font-size: 14pt; }
                div.content { width: 96ex; margin: 0 auto; }
            }
            @media only screen
            and (min-width: 768px)
            and (max-width: 991px) {
                body { font-size: 14pt; }
                div.content { width: 96ex; margin: 0 auto; }
            }
            @media only screen
            and (min-width: 480px)
            and (max-width: 767px) {
                body { font-size: 11pt; }
                div.content { width: 96ex; margin: 0 auto; }
            }
            @media only screen
            and (max-width: 479px) {
                body { font-size: 8pt; }
                div.content { width: 96ex; margin: 0 auto; }
            }
            @media only screen
            and (min-width : 375px)
            and (max-width : 667px) {
                body { font-size: 9.5pt; }
                div.content { width: 96ex; margin: 0; }
            }
            @media only screen
            and (min-width: 1200px) {
                body { font-size: 10pt; margin: 0 4em; }
                div.content { width: 96ex; margin: 0; }
            }
            h1, h2, h3, h4, h5, h6, .h1, .h2, .h3, .h4, .h5, .h6 {
                font-weight: bold;
                /* line-height: 0pt; */
                display: inline;
                white-space: pre;
                font-family: monospace;
                font-size: 1em;
                font-weight: bold;
            }
            pre {
                font-size: 1em;
                margin-top: 0px;
                margin-bottom: 0px;
            }
            .pre {
                white-space: pre;
                font-family: monospace;
            }
            .header{
                font-weight: bold;
            }
            .newpage {
                page-break-before: always;
            }
            .invisible {
                text-decoration: none;
                color: white;
            }
            @media print {
                body {
                    margin-top: 5em;
                    font-family: monospace;
                    font-size: 10.5pt;
                }
                h1, h2, h3, h4, h5, h6 {
                    font-size: 1em;
                }

                a:link, a:visited {
                    color: inherit;
                    text-decoration: none;
                }
                .noprint {
                    display: none;
                }
            }
            @media screen {
                .grey, .grey a:link, .grey a:visited {
                    color: #777;
                }
                .meta-info {
                    background-color: #EEE;
                    width: 96ex;
                }
                .top {
                    border-top: 7px solid #EEE;
                }
                .pad {
                    padding-top: 7px;
                    line-height: 24px;
                    padding-bottom: 4px;
                }
                .bgwhite  { background-color: white; }
                .bgred    { background-color: #F44; }
                .bggrey   { background-color: #666; }
                .bgbrown  { background-color: #840; }
                .bgorange { background-color: #FA0; }
                .bgyellow { background-color: #EE0; }
                .bgmagenta{ background-color: #F4F; }
                .bgblue   { background-color: #66F; }
                .bgcyan   { background-color: #4DD; }
                .bggreen  { background-color: #4F4; }

                .legend   { font-size: 90%; }
                .cplate   { font-size: 70%; border: solid grey 1px; }
            }

            
    .bgwhite  { background-color: white; }
    .bgred    { background-color: #F44; }
    .bggrey   { background-color: #666; }
    .bgbrown  { background-color: #840; }
    .bgorange { background-color: #FA0; }
    .bgyellow { background-color: #EE0; }
    .bgmagenta{ background-color: #F4F; }
    .bgblue   { background-color: #66F; }
    .bgcyan   { background-color: #4DD; }
    .bggreen  { background-color: #4F4; }
    .draftcontent { margin-top:1em;}

        </style>
        
    <link rel="alternate"
          type="application/atom+xml"
          title="Document changes"
          href="/feed/document-changes/draft-cai-ssdp-v1/">
    <meta name="description"
          
              content="Simple Service Discovery Protocol/1.0 (Internet-Draft, 1999)"
          >

        
            <link rel="shortcut icon"
                  href="https://www.ietf.org/lib/dt/8.3.1/ietf/images/ietf-icon-blue3.png">
        
        <link rel="apple-touch-icon"
              href="https://www.ietf.org/lib/dt/8.3.1/ietf/images/apple-touch-icon.png">
    </head>
    <body >
        <div class="content" id="content">
            
<!-- [html-validate-disable-block no-inline-style, attr-quotes, void-style -- FIXME: it's everywhere in this old code] -->
    
    <div class="rfcmarkup">
        <div class="noprint" style="height: .5em;">
            <div onmouseover="this.style.cursor='pointer';"
                 onclick="showLegend();"
                 onmouseout="hideLegend()"
                 style="height: .5em; min-height: .5em; width: 96ex; "
                 class="meta-info bgred"
                 title="Click for color legend.">
            </div>
            <div id="legend"
                 class="meta-info noprint pre legend"
                 style="position:absolute; top: 4px; left: 4ex; visibility:hidden; background-color: white; padding: 4px 9px 5px 7px; border: solid #345 1px; "
                 onmouseover="showLegend();"
                 onmouseout="hideLegend();">
            </div>
        </div>
        
            <div class="noprint">
                <pre class="pre meta-info">[<a href="https://datatracker.ietf.org" title="Document search and retrieval page">Search</a>] [<a href="https://www.ietf.org/archive/id/draft-cai-ssdp-v1-03.txt" title="Plaintext version of this document">txt</a>|<a href="/doc/pdf/draft-cai-ssdp-v1-03">pdfized</a>|<a href="/doc/draft-cai-ssdp-v1/03/bibtex/" title="BibTex entry for this document">bibtex</a>] [<a href="/doc/draft-cai-ssdp-v1/" title="Datatracker information for this document">Tracker</a>] [<a href="mailto:draft-cai-ssdp-v1@ietf.org?subject=draft-cai-ssdp-v1" title="Send email to the document authors">Email</a>] [<a href="https://www.ietf.org/rfcdiff?difftype=--hwdiff&amp;url2=draft-cai-ssdp-v1-03.txt" title="Inline diff (wdiff)">Diff1</a>] [<a href="https://www.ietf.org/rfcdiff?url2=draft-cai-ssdp-v1-03.txt" title="Side-by-side diff">Diff2</a>] [<a href="https://www.ietf.org/tools/idnits?url=https://www.ietf.org/archive/id/draft-cai-ssdp-v1-03.txt" title="Run an idnits check of this document">Nits</a>]
Versions: <a href="/doc/html/draft-cai-ssdp-v1-00">00</a> <a href="/doc/html/draft-cai-ssdp-v1-01">01</a> <a href="/doc/html/draft-cai-ssdp-v1-02">02</a> <a href="/doc/html/draft-cai-ssdp-v1-03"><b>03</b></a>                                                   </pre>
            </div>
        
        <div class="draftcontent"><pre>Internet Engineering Task Force                        Yaron Y. Goland
INTERNET DRAFT                                                Ting Cai
                                                            Paul Leach
                                                                 Ye Gu
                                                 Microsoft Corporation
                                                      Shivaun Albright
                                               Hewlett-Packard Company
                                                      October 28, 1999
                                                    Expires April 2000



                 <span class="h1">Simple Service Discovery Protocol/1.0</span>
                      <span class="h1">Operating without an Arbiter</span>
                       <span class="h1">&lt;<a href="/doc/html/draft-cai-ssdp-v1-03.txt">draft-cai-ssdp-v1-03.txt</a>&gt;</span>



Status of this Memo

   This document is an Internet-Draft and is in full conformance with
   all provisions of <a href="/doc/html/rfc2026#section-10">Section&nbsp;10 of RFC2026</a>.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six
   months and may be updated, replaced, or obsoleted by other documents
   at any time.  It is inappropriate to use Internet- Drafts as
   reference material or to cite them other than as &quot;work in progress.&quot;

   The list of current Internet-Drafts can be accessed at
   <a href="https://www.ietf.org/ietf/1id-abstracts.txt">http://www.ietf.org/ietf/1id-abstracts.txt</a>

   The list of Internet-Draft Shadow Directories can be accessed at
   <a href="https://www.ietf.org/shadow.html">http://www.ietf.org/shadow.html</a>.

   Please send comments to the SSDP mailing list. Subscription
   information for the SSDP mailing list is available at
   <a href="http://www.upnp.org/resources/ssdpmail.htm">http://www.upnp.org/resources/ssdpmail.htm</a>.

Abstract

   The Simple Service Discovery Protocol (SSDP) provides a mechanism
   where by network clients, with little or no static configuration,
   can discover network services. SSDP accomplishes this by providing
   for multicast discovery support as well as server based notification
   and discovery routing.

Table of Contents

   Status of this Memo................................................<a href="#page-1">1</a>
   Abstract...........................................................<a href="#page-1">1</a>


<span class="grey">Goland et al.                                                 [Page 1]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-2" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   Table of Contents..................................................<a href="#page-1">1</a>
   <a href="#section-1">1</a>.    Changes Since 02.............................................<a href="#page-3">3</a>
   <a href="#section-2">2</a>.    Introduction.................................................<a href="#page-3">3</a>
      <a href="#section-2.1">2.1</a>.  Problem Statement.........................................<a href="#page-3">3</a>
      <a href="#section-2.2">2.2</a>.  Proposed Solution.........................................<a href="#page-4">4</a>
         <a href="#section-2.2.1">2.2.1</a>. Message Flow on the SSDP Multicast Channel...........<a href="#page-4">4</a>
         <a href="#section-2.2.2">2.2.2</a>. SSDP Discovery Information Caching Model.............<a href="#page-4">4</a>
      <a href="#section-2.3">2.3</a>.  Design Rationale..........................................<a href="#page-5">5</a>
         <a href="#section-2.3.1">2.3.1</a>. Message Flow on the SSDP Multicast Channel...........<a href="#page-5">5</a>
         <a href="#section-2.3.2">2.3.2</a>. SSDP Discovery Information Caching Model.............<a href="#page-7">7</a>
   <a href="#section-3">3</a>.    Terminology..................................................<a href="#page-8">8</a>
   <a href="#section-4">4</a>.    SSDP Discovery Requests......................................<a href="#page-8">8</a>
      <a href="#section-4.1">4.1</a>.  Problem Statement.........................................<a href="#page-8">8</a>
      <a href="#section-4.2">4.2</a>.  Proposed Solution.........................................<a href="#page-8">8</a>
      <a href="#section-4.3">4.3</a>.  Design Rationale.........................................<a href="#page-10">10</a>
         4.3.1. Why is the ST header so limited? Why doesn&#x27;t it support
         at least and/or/not? Why not name/value pair searching?.....<a href="#page-10">10</a>
         4.3.2. If we are using the SEARCH method why aren&#x27;t you using
         the DASL search syntax?.....................................<a href="#page-10">10</a>
         4.3.3. Why can we only specify one search type in the ST
         header of a ssdp:discover request?..........................<a href="#page-10">10</a>
         4.3.4. Why do we only provide support for multicast UDP, not
         TCP, ssdp:discover requests?................................<a href="#page-10">10</a>
         4.3.5. Why do we require that responses without caching
         information not be cached at all?...........................<a href="#page-11">11</a>
   <a href="#section-5">5</a>.    SSDP Presence Announcements.................................<a href="#page-11">11</a>
      <a href="#section-5.1">5.1</a>.  Problem Statement........................................<a href="#page-11">11</a>
      <a href="#section-5.2">5.2</a>.  Proposed Solution........................................<a href="#page-11">11</a>
         <a href="#section-5.2.1">5.2.1</a>. ssdp:alive..........................................<a href="#page-11">11</a>
         <a href="#section-5.2.2">5.2.2</a>. ssdp:byebye.........................................<a href="#page-12">12</a>
      <a href="#section-5.3">5.3</a>.  Design Rationale.........................................<a href="#page-13">13</a>
         <a href="#section-5.3.1">5.3.1</a>. Why are we using GENA NOTIFY requests?..............<a href="#page-13">13</a>
         5.3.2. Why is there no response to the ssdp:alive/ssdp:byebye
         requests sent to the SSDP multicast channel/port?...........<a href="#page-13">13</a>
         5.3.3. Could NTS values other than ssdp:alive/ssdp:byebye be
         sent to the SSDP multicast channel/port?....................<a href="#page-13">13</a>
         5.3.4. Why do we include the NT header on ssdp:byebye
         requests?...................................................<a href="#page-13">13</a>
         <a href="#section-5.3.5">5.3.5</a>. Shouldn&#x27;t the NT and NTS values be switched?........<a href="#page-13">13</a>
   <a href="#section-6">6</a>.    SSDP Auto-Shut-Off Algorithm................................<a href="#page-13">13</a>
      <a href="#section-6.1">6.1</a>.  Problem Statement........................................<a href="#page-13">13</a>
      <a href="#section-6.2">6.2</a>.  Proposed Solution........................................<a href="#page-13">13</a>
      <a href="#section-6.3">6.3</a>.  Design Rationale.........................................<a href="#page-14">14</a>
         <a href="#section-6.3.1">6.3.1</a>. Why do we need an auto-shut-off algorithm?..........<a href="#page-14">14</a>
         6.3.2. Why not just require everyone to support directories
         and thus get around the scaling issue?......................<a href="#page-15">15</a>
   <a href="#section-7">7</a>.    ssdp:all....................................................<a href="#page-15">15</a>
      <a href="#section-7.1">7.1</a>.  Problem Statement........................................<a href="#page-15">15</a>
      <a href="#section-7.2">7.2</a>.  Proposed Solution........................................<a href="#page-15">15</a>
      <a href="#section-7.3">7.3</a>.  Design Rationale.........................................<a href="#page-16">16</a>
         <a href="#section-7.3.1">7.3.1</a>. Why would anyone want to enumerate all services?....<a href="#page-16">16</a>
   <a href="#section-8">8</a>.    SSDP Reserved Multicast Channel.............................<a href="#page-16">16</a>


<span class="grey">Goland et al.                                                 [Page 2]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-3" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


      <a href="#section-8.1">8.1</a>.  Problem Statement........................................<a href="#page-16">16</a>
      <a href="#section-8.2">8.2</a>.  Proposed Solution........................................<a href="#page-16">16</a>
      <a href="#section-8.3">8.3</a>.  Design Rationale.........................................<a href="#page-16">16</a>
         8.3.1. Why didn&#x27;t SSDP just get a static local administrative
         scope address rather than a relative address?...............<a href="#page-16">16</a>
         <a href="#section-8.3.2">8.3.2</a>. Why does SSDP need to use a port other than 80?.....<a href="#page-16">16</a>
   <a href="#section-9">9</a>.    HTTP Headers................................................<a href="#page-17">17</a>
      <a href="#section-9.1">9.1</a>.  USN Header...............................................<a href="#page-17">17</a>
      <a href="#section-9.2">9.2</a>.  ST Header................................................<a href="#page-17">17</a>
   <a href="#section-10">10</a>.   Security Considerations.....................................<a href="#page-17">17</a>
   <a href="#section-11">11</a>.   IANA Considerations.........................................<a href="#page-17">17</a>
   <a href="#section-12">12</a>.   Appendix - Constants........................................<a href="#page-17">17</a>
   <a href="#section-13">13</a>.   Acknowledgements............................................<a href="#page-17">17</a>
   <a href="#section-14">14</a>.   References..................................................<a href="#page-17">17</a>
   <a href="#section-15">15</a>.   Author&#x27;s Addresses..........................................<a href="#page-18">18</a>

<span class="h2"><a class="selflink" id="section-1" href="#section-1">1</a>.   Changes Since 02</span>

   The entire specification has been extensively re-written. As such
   the reader is advised to re-read the entire specification rather
   than to just look for particular changes.

   Removed the arbiter and related functionality.

   Spec used to contain both ssdp:discover and ssdp:discovery, settled
   on ssdp:discover.

   Changed SSDP multicast message examples to use the reserved relative
   multicast address &quot;5&quot; provided by IANA. In the local administrative
   scope, the only scope currently used by SSDP, this address
   translates to 239.255.255.250.

   An application has been made for a reserved port for SSDP but no
   response from IANA has been received.

<span class="h2"><a class="selflink" id="section-2" href="#section-2">2</a>.   Introduction</span>

   [Ed. Note: In my experience, one of the best ways to enable a
   specification to be quickly and successfully developed is to provide
   a problem statement, a proposed solution and a design rationale. I
   came across this three-part design structure when Larry Masinter
   proposed it to the WebDAV WG. To that end, I have divided this spec
   in a similar manner. Once the specification is sufficiently mature,
   the problem statement and design rationale sections will be placed
   in a separate document and the proposed solutions will be presented
   for standardization.]

   This document assumes the reader is very familiar with [<a href="/doc/html/rfc2616" title="H. Frystyk">RFC2616</a>],
   [<a href="#ref-HTTPUDP">HTTPUDP</a>], [<a href="#ref-GENA" title="S. Aggarwal">GENA</a>], [<a href="#ref-MAN" title="P. Leach">MAN</a>] and [<a href="/doc/html/rfc2365">RFC2365</a>].

<span class="h3"><a class="selflink" id="section-2.1" href="#section-2.1">2.1</a>. Problem Statement</span>



<span class="grey">Goland et al.                                                 [Page 3]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-4" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   A mechanism is needed to allow HTTP clients and HTTP resources to
   discover each other in local area networks. That is, a HTTP client
   may need a particular service that may be provided by one or more
   HTTP resources. The client needs a mechanism to find out which HTTP
   resources provide the service the client desires.

   For the purposes of this specification the previously mentioned HTTP
   client will be referred to as a SSDP client. The previous mentioned
   HTTP resource will be referred to as a SSDP service.

   In the simplest case this discovery mechanism needs to work without
   any configuration, management or administration. For example, if a
   user sets up a home network or a small company sets up a local area
   network they must not be required to configure SSDP before SSDP can
   be used to help them discover SSDP services in the form of Printers,
   Scanners, Fax Machines, etc.

   It is a non-goal for SSDP to provide for multicast scope bridging or
   for advanced query facilities.

<span class="h3"><a class="selflink" id="section-2.2" href="#section-2.2">2.2</a>. Proposed Solution</span>

<span class="h4"><a class="selflink" id="section-2.2.1" href="#section-2.2.1">2.2.1</a>.    Message Flow on the SSDP Multicast Channel</span>

   The following is an overview of the messages used to implement SSDP.

   SSDP clients discover SSDP services using the reserved local
   administrative scope multicast address 239.255.255.250 over the SSDP
   port [NOT YET ALLOCATED BY IANA].

   For brevity&#x27;s sake the SSDP reserved local administrative scope
   multicast address and port will be referred to as the SSDP multicast
   channel/Port.

   Discovery occurs when a SSDP client multicasts a HTTP UDP discovery
   request to the SSDP multicast channel/Port. SSDP services listen to
   the SSDP multicast channel/Port in order to hear such discovery
   requests. If a SSDP service hears a HTTP UDP discovery request that
   matches the service it offers then it will respond using a unicast
   HTTP UDP response.

   SSDP services may send HTTP UDP notification announcements to the
   SSDP multicast channel/port to announce their presence.

   Hence two types of SSDP requests will be sent across the SSDP
   multicast channel/port. The first are discovery requests, a SSDP
   client looking for SSDP services. The second are presence
   announcements, a SSDP service announcing its presence.

<span class="h4"><a class="selflink" id="section-2.2.2" href="#section-2.2.2">2.2.2</a>.    SSDP Discovery Information Caching Model</span>




<span class="grey">Goland et al.                                                 [Page 4]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-5" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   The following provides an overview of the data provided in a SSDP
   system.

   Services are identified by a unique pairing of a service type URI
   and a Unique Service Name (USN) URI.

   Service types identify a type of service, such as a refrigerator,
   clock/radio, what have you. The exact meaning of a service type is
   outside the scope of this specification. For the purposes of this
   specification, a service type is an opaque identifier that
   identifies a particular type of service.

   A USN is a URI that uniquely identifies a particular instance of a
   service. USNs are used to differentiate between two services with
   the same service type.

   In addition to providing both a service type and a USN, discovery
   results and presence announcements also provide expiration and
   location information.

   Location information identifies how one should contact a particular
   service. One or more location URIs may be included in a discovery
   response or a presence announcement.

   Expiration information identifies how long a SSDP client should keep
   information about the service in its cache. Once the entry has
   expired it is to be removed from the SSDP client&#x27;s cache.

   Thus a SSDP client service cache might look like:

   USN URI          | Service Type URI | Expiration | Location
   -----------------|------------------|------------|------------------
   upnp:uuid:k91... | upnp:clockradio  | 3 days     | <a href="http://foo.com/cr">http://foo.com/cr</a>
   -----------------|------------------|------------|------------------
   uuid:x7z...      | ms:wince         | 1 week     | <a href="http://msce/win">http://msce/win</a>
   -----------------|------------------|------------|------------------

   In the previous example both USN URIs are actually UUIDs such as
   upnp:uuid:k91d4fae-7dec-11d0-a765-00a0c91c6bf6.

   If an announcement or discovery response is received that has a USN
   that matches an entry already in the cache then the information in
   the cache is to be completely replaced with the information in the
   announcement or discovery response.

<span class="h3"><a class="selflink" id="section-2.3" href="#section-2.3">2.3</a>. Design Rationale</span>

   [Ed. Note: In my own experience one of the most powerful ways to
   explain design rationale is in a question/answer form. Therefore I
   have used that format here.]

<span class="h4"><a class="selflink" id="section-2.3.1" href="#section-2.3.1">2.3.1</a>.    Message Flow on the SSDP Multicast Channel</span>


<span class="grey">Goland et al.                                                 [Page 5]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-6" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>



   Please see <a href="#section-8.3">section 8.3</a> for more design rationale behind our use of
   multicasting.

<span class="h5"><a class="selflink" id="section-2.3.1.1" href="#section-2.3.1.1">2.3.1.1</a>.  Why use multicast for communication?</span>

   We needed a solution for communication that would work even if there
   was no one around to configure things. The easiest solution would
   have been to build a discovery server, but who would set the server
   up? Who would maintain it? We needed a solution that could work even
   if no one had any idea what discovery was. By using multicasting we
   have the equivalent of a &quot;party channel.&quot; Everyone can just grab the
   channel and scream out what they need and everyone else will hear.
   This means no configuration worries. Of course it brings up other
   problems which are addressed throughout this specification.

<span class="h5"><a class="selflink" id="section-2.3.1.2" href="#section-2.3.1.2">2.3.1.2</a>.  Why use a local administrative scope multicast address?</span>

   Multicasting comes in many scopes, from link local all the way to
   &quot;the entire Internet.&quot; Our goal is to provide for discovery for
   local area networks not for the entire Internet. LANs often are
   bridged/routed so a link local multicast scope was too restrictive.
   The next level up was a local administrative scope. The idea being
   that your administrator decides how many machines should be grouped
   together and considered a &quot;unit&quot;. This seemed the ideal scope to use
   for a local discovery protocol.

<span class="h5"><a class="selflink" id="section-2.3.1.3" href="#section-2.3.1.3">2.3.1.3</a>.  Why does SSDP support both service discovery requests as well</span>
as service presence announcements?

   Some discovery protocols only support discovery requests, that is,
   the client must send out a request in order to find out who is
   around. The downside to such solutions is that they tend to be very
   expensive on the wire. For example, we want to display to our user
   all the VCRs in her house. So we send out a discovery request.
   However our user has just purchased a new VCR and, after starting
   our program, plugged it in. The only way we would find out about the
   new VCR and be able to display it on our user&#x27;s screen is by
   constantly sending out discovery requests. Now imagine every client
   in the network having to send out a torrent of discovery requests
   for service they care about in order to make sure they don&#x27;t miss a
   new service coming on-line.

   Other systems use the opposite extreme, they only support
   announcements. Therefore, when our user opens the VCR display window
   we would just sit and listen for announcements. In such systems all
   the services have to send out a constant stream of announcements in
   order to make sure that no one misses them. Users aren&#x27;t the most
   patient people in the world so each service will probably need to
   announce itself at least every few seconds. This constant stream of
   traffic does horrible things to network efficient, especially for
   shared connections like Ethernets.


<span class="grey">Goland et al.                                                 [Page 6]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-7" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>



   SSDP decided to adopt a hybrid approach and do both discovery and
   announcements. This can be incredibly efficient. When a service
   first comes on-line it will send out an announcement so that
   everyone knows it is there. At that point it shouldn&#x27;t ever need to
   send out another announcement unless it is going off-line, has
   changed state or its cache entry is about to expire. Any clients who
   come on-line after the service came on-line will discover the
   desired service by sending out a discovery request. The client
   should never need to repeat the discovery request because any
   services that subsequently come on-line will announce themselves.
   The end result is that no one needs to send out steady streams of
   messages. The entire system is event driven, only when things change
   will messages need to be sent out. The cost, however, is that the
   protocol is more complex. We felt this was a price worth paying as
   it meant that SSDP could be used successfully in fairly large
   networks.

<span class="h5"><a class="selflink" id="section-2.3.1.4" href="#section-2.3.1.4">2.3.1.4</a>.  Doesn&#x27;t the caching information turn SSDP back into a</span>
&quot;announcement driven&quot; protocol?

   Discovery protocols that only support announcements generally have
   to require services to send announcements every few seconds.
   Otherwise users screens will take too long to update with
   information about which services are available.

   SSDP, on the other hand, allows the service to inform clients how
   long they should assume the service is around. Thus a service can
   set a service interval to seconds, minutes, days, weeks, months or
   even years.

   Clients do not have to wait around for cache update messages because
   they can perform discovery.

<span class="h4"><a class="selflink" id="section-2.3.2" href="#section-2.3.2">2.3.2</a>.    SSDP Discovery Information Caching Model</span>

<span class="h5"><a class="selflink" id="section-2.3.2.1" href="#section-2.3.2.1">2.3.2.1</a>.  Why do we need USNs, isn&#x27;t the location good enough?</span>

   When a service announces itself it usually includes a location
   identifying where it may be found. However that location can and
   will change over time. For example, a user may decide to change the
   DNS name assigned to that device. Were we to depend on locations,
   not USNs, when the service&#x27;s location was changed we would think we
   were seeing a brand new service. This would be very disruptive to
   the user&#x27;s experience. Imagine, for example, that the user has set
   up a PC program that programs their VCR based on schedules pulled
   off the Internet. If the user decides to change the VCR&#x27;s name from
   the factory default to something friendly then a location based
   system would loose track of the VCR it is supposed to be programming
   because the name has changed. By using unique Ids instead we are
   able to track the VCR regardless of the name change. So the user can



<span class="grey">Goland et al.                                                 [Page 7]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-8" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   change the VCR&#x27;s name at will and the VCR programming application
   will still be able to program the correct VCR.

<span class="h5"><a class="selflink" id="section-2.3.2.2" href="#section-2.3.2.2">2.3.2.2</a>.  Why are USNs URIs and why are they required to be unique</span>
across the entire URI namespace for all time?

   In general making a name universally unique turns out to usually be
   a very good idea. Mechanisms such as UUIDs allow universally unique
   names to be cheaply created in a decentralized manner. In this case
   making USNs globally unique is very useful because services may be
   constantly moved around, if they are to be successfully tracked they
   need an identifier that isn&#x27;t going to change and isn&#x27;t going to get
   confused with any other service.

   URIs were chosen because they have become the de facto managed
   namespace for use on the Internet. Anytime someone wants to name
   something it is easy to just use a URI.

<span class="h2"><a class="selflink" id="section-3" href="#section-3">3</a>.   Terminology</span>

   SSDP Client - A HTTP client that makes use of a service.

   SSDP Service - A HTTP resource that provides a service used by SSDP
   clients.


   Service Type - A URI that identifies the type or function of a
   particular service.

   Unique Service Name (USN) - A URI that is guaranteed to be unique
   across the entire URI namespace for all time. It is used to uniquely
   identify a particular service in order to allow services with
   identical service type URIs to to be differentiated.

   In addition, the key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;,
   &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in
   <a href="/doc/html/rfc2119">RFC 2119</a> [<a href="/doc/html/rfc2119">RFC2119</a>].

<span class="h2"><a class="selflink" id="section-4" href="#section-4">4</a>.   SSDP Discovery Requests</span>

<span class="h3"><a class="selflink" id="section-4.1" href="#section-4.1">4.1</a>. Problem Statement</span>

   A mechanism is needed for SSDP clients to find desired SSDP
   services.

<span class="h3"><a class="selflink" id="section-4.2" href="#section-4.2">4.2</a>. Proposed Solution</span>

   The SEARCH method, introduced by [<a href="#ref-DASL" title="J. Davis">DASL</a>], is extended using the [<a href="#ref-MAN" title="P. Leach">MAN</a>]
   mechanism to provide for SSDP discovery.

   The SSDP SEARCH extension is identified by the URI ssdp:discover.


<span class="grey">Goland et al.                                                 [Page 8]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-9" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>



   For brevity&#x27;s sake a HTTP SEARCH method enhanced with the
   ssdp:discover functionality will be referred to as a ssdp:discover
   request.

   ssdp:discover requests MUST contain a ST header. ssdp:discover
   requests MAY contain a body but the body MAY be ignored if not
   understood by the HTTP service.

   The ST header contains a single URI. SSDP clients may use the ST
   header to specify the service type they want to discover.

   This specification only specifies the use of ssdp:discover requests
   over HTTP Multicast UDP although it is expected that future
   specifications will expand the definition to handle ssdp:discover
   requests sent over HTTP TCP.

   ssdp:discover requests sent to the SSDP multicast channel/port MUST
   have a request-URI of &quot;*&quot;. Note that future specifications may allow
   for other request-URIs to be used so implementations based on this
   specification MUST be ready to ignore ssdp:discover requests on the
   SSDP multicast channel/port with a request-URI other than &quot;*&quot;.

   Only SSDP services that have a service type that matches the value
   in the ST header MAY respond to a ssdp:discover request on the SSDP
   multicast channel/port.

   Responses to ssdp:discover requests sent over the SSDP multicast
   channel/port are to be sent to the IP address/port the ssdp:discover
   request came from.

   A response to a ssdp:discover request SHOULD include the service&#x27;s
   location expressed through the Location and/or AL header. A
   successful response to a ssdp:discover request MUST also include the
   ST and USN headers.

   Response to ssdp:discover requests SHOULD contain a cache-control:
   max-age or Expires header. If both are present then they are to be
   processed in the order specified by HTTP/1.1, that is, the cache-
   control header takes precedence of the Expires header. If neither
   the cache-control nor the Expires header is provided on the response
   to a ssdp:discover request then the information contained in that
   response MUST NOT be cached by SSDP clients.

<span class="h5"><a class="selflink" id="section-4.2.1.1" href="#section-4.2.1.1">4.2.1.1</a>.  Example</span>

   M-SEARCH * HTTP/1.1
   S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6
   Host: 239.255.255.250:reservedSSDPport
   Man: &quot;ssdp:discover&quot;
   ST: ge:fridge
   MX: 3


<span class="grey">Goland et al.                                                 [Page 9]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-10" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>



   HTTP/1.1 200 OK
   S: uuid:ijklmnop-7dec-11d0-a765-00a0c91e6bf6
   Ext:
   Cache-Control: no-cache=&quot;Ext&quot;, max-age = 5000
   ST: ge:fridge
   USN: uuid:abcdefgh-7dec-11d0-a765-00a0c91e6bf6
   AL: &lt;blender:ixl&gt;&lt;<a href="https://foo/bar">http://foo/bar</a>&gt;

<span class="h3"><a class="selflink" id="section-4.3" href="#section-4.3">4.3</a>. Design Rationale</span>

<span class="h4"><a class="selflink" id="section-4.3.1" href="#section-4.3.1">4.3.1</a>.    Why is the ST header so limited? Why doesn&#x27;t it support at</span>
least and/or/not? Why not name/value pair searching?

   Deciding the &quot;appropriate&quot; level of search capability is a hopeless
   task. So we decided to pare things back to the absolute minimum, a
   single opaque token, and see what happens. The result so far has
   been a very nice, simple, easy to implement, easy to use discovery
   system. There are lots of great features it doesn&#x27;t provide but most
   of them, such as advanced queries and scoping, require a search
   engine and a directory. This level of capability is beyond many
   simple devices, exactly the sort of folks we are targeting with
   SSDP. Besides, search functionality seems to be an all or nothing
   type of situation. Either you need a brain dead simple search
   mechanism or you need a full fledged near SQL class search system.
   Instead of making SSDP the worst of both worlds we decided to just
   focus on the dirt simple search problem and leave the more advanced
   stuff to the directory folk.

<span class="h4"><a class="selflink" id="section-4.3.2" href="#section-4.3.2">4.3.2</a>.    If we are using the SEARCH method why aren&#x27;t you using the</span>
DASL search syntax?

   We couldn&#x27;t come up with a good reason to force our toaster ovens to
   learn XML. The features the full-fledged DASL search syntax provides
   are truly awesome and thus way beyond our simple scenarios. We fully
   expect that DASL will be the preferred solution for advanced search
   scenarios, but that isn&#x27;t what this draft is about.

<span class="h4"><a class="selflink" id="section-4.3.3" href="#section-4.3.3">4.3.3</a>.    Why can we only specify one search type in the ST header of a</span>
ssdp:discover request?

   We wanted to start as simple as possible and be forced, kicking and
   screaming, into adding additional complexity. The simplest solution
   was to only allow a single value in the ST header. We were also
   concerned that if we allowed multiple values into the ST headers
   somebody would try to throw in and/or/not functionality. Given the
   minimal byte savings of allowing multiple values into the ST header
   it seems better to just leave the protocol simpler.

<span class="h4"><a class="selflink" id="section-4.3.4" href="#section-4.3.4">4.3.4</a>.    Why do we only provide support for multicast UDP, not TCP,</span>
ssdp:discover requests?



<span class="grey">Goland et al.                                                [Page 10]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-11" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   We only define what we need to make the discovery protocol work and
   we don&#x27;t need TCP to make the discovery protocol work. Besides to
   make TCP discovery really work you need to be able to handle
   compound responses which means you need a compound response format
   which is probably XML and that is more than we wanted to handle.
   Eventually we expect that you will be able to go up to the SSDP port
   on a server using a HTTP TCP request and discover what service, if
   any, lives there. But that will be described in a future
   specification.

<span class="h4"><a class="selflink" id="section-4.3.5" href="#section-4.3.5">4.3.5</a>.    Why do we require that responses without caching information</span>
not be cached at all?

   Because that was a lot easier thing to do then trying to explain the
   various heuristics one could use to deal with services who don&#x27;t
   provide caching information.

<span class="h2"><a class="selflink" id="section-5" href="#section-5">5</a>.   SSDP Presence Announcements</span>

<span class="h3"><a class="selflink" id="section-5.1" href="#section-5.1">5.1</a>. Problem Statement</span>

   A mechanism is needed for SSDP services to be able to let interested
   SSDP clients know of their presence.

   A mechanism is needed to allow SSDP services to update expiration
   information in cache entries regarding them.

   A mechanism is needed to allow SSDP services to notify interested
   SSDP clients when their location changes.

   A mechanism is needed to allow SSDP services to inform interested
   SSDP clients that they are going to de-activate themselves.

<span class="h3"><a class="selflink" id="section-5.2" href="#section-5.2">5.2</a>. Proposed Solution</span>

<span class="h4"><a class="selflink" id="section-5.2.1" href="#section-5.2.1">5.2.1</a>.    ssdp:alive</span>

   SSDP services may declare their presence on the network by sending a
   [<a href="#ref-GENA" title="S. Aggarwal">GENA</a>] NOTIFY method using the NTS value ssdp:alive to the SSDP
   multicast channel/port.

   For brevity&#x27;s sake HTTP NOTIFY methods with the NTS value ssdp:alive
   will be referred to as ssdp:alive requests.

   When a ssdp:alive request is received whose USN matches the USN of
   an entry already in the SSDP client&#x27;s cache then all information
   regarding that USN is to be replaced with the information on the
   ssdp:alive request. Hence ssdp:alive requests can be used to update
   location information and prevent cache entries from expiring.





<span class="grey">Goland et al.                                                [Page 11]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-12" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   The value of NT on a ssdp:alive request MUST be set to the service&#x27;s
   service type. ssdp:alive requests MUST contain a USN header set to
   the SSDP service&#x27;s USN.

   ssdp:alive requests SHOULD contain a Location and/or AL header. If
   there is no DNS support available on the local network then at least
   one location SHOULD be provided using an IP address of the SSDP
   service.

   ssdp:alive requests SHOULD contain a cache-control: max-age or
   Expires header. If both are present then they are to be processed in
   the order specified by HTTP/1.1, that is, the cache-control header
   takes precedence of the Expires header. If neither the cache-control
   nor the Expires header is provided the information in the ssdp:alive
   request MUST NOT be cached by SSDP clients.

   There is no response to a ssdp:alive sent to the SSDP multicast
   channel/port.

<span class="h5"><a class="selflink" id="section-5.2.1.1" href="#section-5.2.1.1">5.2.1.1</a>.  Example</span>

   NOTIFY * HTTP/1.1
   Host: 239.255.255.250:reservedSSDPport
   NT: blenderassociation:blender
   NTS: ssdp:alive
   USN: someunique:idscheme3
   AL: &lt;blender:ixl&gt;&lt;<a href="https://foo/bar">http://foo/bar</a>&gt;
   Cache-Control: max-age = 7393

<span class="h4"><a class="selflink" id="section-5.2.2" href="#section-5.2.2">5.2.2</a>.    ssdp:byebye</span>

   SSDP services may declare their intention to cease operating by
   sending a [<a href="#ref-GENA" title="S. Aggarwal">GENA</a>] NOTIFY method using the NTS value ssdp:byebye to
   the SSDP multicast channel/port.

   For brevity&#x27;s sake HTTP NOTIFY methods with the NTS value
   ssdp:byebye will be referred to as ssdp:byebye requests.

   The value of NT on a ssdp:byebye request MUST be set to the
   service&#x27;s service type. ssdp:byebye requests MUST contain a USN
   header set to the SSDP service&#x27;s USN.

   There is no response to a ssdp:byebye sent to the SSDP multicast
   channel/port.

   When a ssdp:byebye request is received all cached information
   regarding that USN SHOULD be removed.

<span class="h5"><a class="selflink" id="section-5.2.2.1" href="#section-5.2.2.1">5.2.2.1</a>.  Example</span>

   NOTIFY * HTTP/1.1
   Host: 239.255.255.250:reservedSSDPport


<span class="grey">Goland et al.                                                [Page 12]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-13" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   NT: someunique:idscheme3
   NTS: ssdp:byebye
   USN: someunique:idscheme3

<span class="h3"><a class="selflink" id="section-5.3" href="#section-5.3">5.3</a>. Design Rationale</span>

<span class="h4"><a class="selflink" id="section-5.3.1" href="#section-5.3.1">5.3.1</a>.    Why are we using GENA NOTIFY requests?</span>

   We needed to use some notification format and GENA seemed as good as
   any. Moving forward, GENA gives us a framework to do notification
   subscriptions which will be necessary if SSDP services are to be
   able to provide status updates across the wilds of the Internet
   without depending on the largely non-existent Internet multicast
   infrastructure.


<span class="h4"><a class="selflink" id="section-5.3.2" href="#section-5.3.2">5.3.2</a>.    Why is there no response to the ssdp:alive/ssdp:byebye</span>
requests sent to the SSDP multicast channel/port?

   What response would be sent? There isn&#x27;t much of a point of having
   the SSDP clients send response saying &quot;we received your
   notification&quot; since there may be a lot of them.

<span class="h4"><a class="selflink" id="section-5.3.3" href="#section-5.3.3">5.3.3</a>.    Could NTS values other than ssdp:alive/ssdp:byebye be sent to</span>
the SSDP multicast channel/port?

   Yes.

<span class="h4"><a class="selflink" id="section-5.3.4" href="#section-5.3.4">5.3.4</a>.    Why do we include the NT header on ssdp:byebye requests?</span>

   Technically it isn&#x27;t necessary since the only useful information is
   the USN. But we want to stick with the GENA format that requires a
   NT header. In truth the requirement of including the NT header is a
   consequence of the next issue.

<span class="h4"><a class="selflink" id="section-5.3.5" href="#section-5.3.5">5.3.5</a>.    Shouldn&#x27;t the NT and NTS values be switched?</span>

   Yes, they should. Commands such as ssdp:alive and ssdp:byebye should
   be NT values and the service type, where necessary, should be the
   NTS. The current mix-up is a consequence of a previous design where
   the NT header was used in a manner much like we use the USN today.
   This really needs to change.

<span class="h2"><a class="selflink" id="section-6" href="#section-6">6</a>.   SSDP Auto-Shut-Off Algorithm</span>

<span class="h3"><a class="selflink" id="section-6.1" href="#section-6.1">6.1</a>. Problem Statement</span>

   A mechanism is needed to ensure that SSDP does not cause such a high
   level of traffic that it overwhelms the network it is running on.

<span class="h3"><a class="selflink" id="section-6.2" href="#section-6.2">6.2</a>. Proposed Solution</span>



<span class="grey">Goland et al.                                                [Page 13]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-14" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   [Ed. Note: We have a proposed solution but it is still a bit rough,
   so we will be publishing to the SSDP mailing list for further
   discussion before including it in the draft.]

<span class="h3"><a class="selflink" id="section-6.3" href="#section-6.3">6.3</a>. Design Rationale</span>

<span class="h4"><a class="selflink" id="section-6.3.1" href="#section-6.3.1">6.3.1</a>.    Why do we need an auto-shut-off algorithm?</span>

   The general algorithm for figuring out how much bandwidth SSDP uses
   over a fixed period of time based on the number of ssdp:discover
   requests is :

   DR = Total number of SSDP clients making ssdp:discover requests over
   the time period in question.
   RS = Total number of services that will respond to the ssdp:discover
   requests over the time period in question.
   AM = Average size of the ssdp:discover requests/responses.
   TP = Time period in question.

   ((DR*3 + DR*9*RS)*AM)/TP

   The 3 is the number of times the ssdp:discover request will be
   repeated.
   The 9 is the number of times the unicast responses to the
   ssdp:discover requests will be sent out assuming the worst case in
   which all 3 original requests are received.

   So let&#x27;s look at a real world worst-case scenario. Some companies,
   in order to enable multicast based services such as voice or video
   streaming to be easily configured set their local administrative
   multicast scope to encompass their entire company. This means one
   gets networks with 100,000 machines in a single administrative
   multicast scope. Now imagine that there is a power outage and all
   the machines are coming back up at the same time. Further imagine
   that they all want to refresh their printer location caches so they
   all send out ssdp:discover requests. Let us finally imagine that
   there are roughly 5000 printers in this network. To simplify the
   math we will assume that the ssdp:discover requests are evenly
   distributed over the 30 seconds.

   DR = 100,000 requesting clients
   RS = 5000 services
   AM = 512 bytes
   TP = 30 seconds

   ((100000*3+100000*9*5000)*512)/30 = 76805120000 bytes/s =
   585976.5625 Megabits per second

   This is what one would call an awful number.





<span class="grey">Goland et al.                                                [Page 14]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-15" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   In a more reasonably sized network SSDP is able to handle this worst
   case scenario much better. For example, let&#x27;s look at a network with
   1000 clients and 50 printers.

   DR = 1000 requesting clients
   RS = 50 services
   AM = 512 bytes
   TP = 30 seconds

   ((1000*3+1000*9*50)*512)/30 = 7731200 bytes/s = 59 Mbps

   Now this looks like an awful amount but remember that that this is
   the total data rate needed for 30 seconds. This means that the total
   amount of information SSDP needs to send out to survive a reboot is
   59*30 = 1770 Mb. Therefore a 10 Mbps network, assuming an effective
   data rate 5 Mbps under constant load that means it will take 1770/5
   = 354 seconds = 6 minutes for the network to settle down.

   That isn&#x27;t bad considering that this is an absolute worst case in a
   network with 1000 clients and 50 services all of whom want to talk
   to each other at the exact same instant.

   In either case, there are obvious worst-case scenarios and we need
   to avoid network storms, therefore we need a way for SSDP to de-
   activate before it causes a network storms.

<span class="h4"><a class="selflink" id="section-6.3.2" href="#section-6.3.2">6.3.2</a>.    Why not just require everyone to support directories and thus</span>
get around the scaling issue?

   Many manufacturers stick every protocol they can think of in their
   clients and services. So if your network administrator happened to
   buy some clients and servers that supported SSDP but didn&#x27;t know
   they supported SSDP then you can imagine the problems. Therefore
   even if we required directory support there are still many cases
   where SSDP clients and services may inadvertently end up in a
   network without anyone knowing it and cause problems.

<span class="h2"><a class="selflink" id="section-7" href="#section-7">7</a>.   ssdp:all</span>

<span class="h3"><a class="selflink" id="section-7.1" href="#section-7.1">7.1</a>. Problem Statement</span>

   A mechanism is needed to enable a client to enumerate all the
   services available on a particular SSDP multicast channel/port.

<span class="h3"><a class="selflink" id="section-7.2" href="#section-7.2">7.2</a>. Proposed Solution</span>

   All SSDP services MUST respond to SEARCH requests over the SSDP
   multicast channel/port with the ST value of ssdp:all by responding
   as if the ST value had been their service type.

   For brevity&#x27;s sake a SEARCH request with a ST of ssdp:all will be
   referred to as a ssdp:all request.


<span class="grey">Goland et al.                                                [Page 15]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-16" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>



<span class="h3"><a class="selflink" id="section-7.3" href="#section-7.3">7.3</a>. Design Rationale</span>

<span class="h4"><a class="selflink" id="section-7.3.1" href="#section-7.3.1">7.3.1</a>.    Why would anyone want to enumerate all services?</span>

   This feature is mostly for network analysis tools. It also will
   prove very useful in the feature when directories become SSDP aware.
   They will be able to discover all services, record information about
   them and make that information available outside the local
   administrative multicast scope.

<span class="h2"><a class="selflink" id="section-8" href="#section-8">8</a>.   SSDP Reserved Multicast Channel</span>

<span class="h3"><a class="selflink" id="section-8.1" href="#section-8.1">8.1</a>. Problem Statement</span>

   SSDP needs a local administrative multicast channel that will be
   guaranteed to only be used by SSDP compliant clients and services.

<span class="h3"><a class="selflink" id="section-8.2" href="#section-8.2">8.2</a>. Proposed Solution</span>

   IANA has reserved the relative multicast address &quot;5&quot; for the
   exclusive use of SSDP. In the local administrative scope used by
   this version of SSDP the relative address translates to
   239.255.255.250.

   An application has been put in for a SSDP reserved port but IANA has
   not yet responded.

<span class="h3"><a class="selflink" id="section-8.3" href="#section-8.3">8.3</a>. Design Rationale</span>

<span class="h4"><a class="selflink" id="section-8.3.1" href="#section-8.3.1">8.3.1</a>.    Why didn&#x27;t SSDP just get a static local administrative scope</span>
address rather than a relative address?

   We got a relative address because we expect that SSDP may be used to
   discover basic system services such as directories. In that case if
   you can&#x27;t find a directory in your local scope you may want to try a
   wider multicast scope. This is exactly the sort of functionality
   enabled by MALLOC (<a href="https://www.ietf.org/html.charters/malloc-charter.html">http://www.ietf.org/html.charters/malloc-</a>
   <a href="https://www.ietf.org/html.charters/malloc-charter.html">charter.html</a>). MALLOC allows one to enumerate all the multicast
   scopes that are supported on the network. The SSDP client can then
   try progressively larger scopes to find the service they are seeing.
   However this progressively wider discovery only works if SSDP uses a
   relative address.

<span class="h4"><a class="selflink" id="section-8.3.2" href="#section-8.3.2">8.3.2</a>.    Why does SSDP need to use a port other than 80?</span>

   There is a bug in the Berkley Sockets design that was inherited by
   WinSock as well. The bug is as follows: One can not grab a
   particular port on a particular multicast address without owning the
   same port on the local unicast address.




<span class="grey">Goland et al.                                                [Page 16]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-17" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   The result is that if we used port 80 on the SSDP multicast scope
   then we would require that the SSDP software also grab port 80 for
   the local machine. This would mean that SSDP could only be
   implemented on machines which either didn&#x27;t have HTTP servers or
   whose HTTP servers had been enhanced to support SSDP.

   We felt this was a unnecessary restriction. Therefore we are
   choosing to use a port other than 80 on the SSDP multicast channel.

<span class="h2"><a class="selflink" id="section-9" href="#section-9">9</a>.   HTTP Headers</span>

<span class="h3"><a class="selflink" id="section-9.1" href="#section-9.1">9.1</a>. USN Header</span>

   USN = &quot;USN&quot; &quot;:&quot; AbsoluteURI; defined in <a href="/doc/html/rfc2616#section-3.2.1">section&nbsp;3.2.1 of [RFC2616]</a>

<span class="h3"><a class="selflink" id="section-9.2" href="#section-9.2">9.2</a>. ST Header</span>

   ST = &quot;ST&quot; &quot;:&quot; AbsoluteURI

<span class="h2"><a class="selflink" id="section-10" href="#section-10">10</a>.  Security Considerations</span>

   TBD.

<span class="h2"><a class="selflink" id="section-11" href="#section-11">11</a>.  IANA Considerations</span>

   To ensure correct interoperation based on this specification, IANA
   must reserve the URI namespace starting with &quot;ssdp:&quot; for use by this
   specification, its revisions, and related SSDP specifications.

   IANA has reserved the relative multicast address &quot;5&quot; for exclusive
   use by SSDP. An application has been made for a registered port.

<span class="h2"><a class="selflink" id="section-12" href="#section-12">12</a>.  Appendix - Constants</span>

   MAX_UNIQUE - 50 - Maximum number of unique IP address/port pairs
   that may be sent over UDP before tripping the auto-shut-off
   algorithm.

   MAX_COUNT - 30 seconds - When the &quot;go quiet&quot; process is begun a
   message is sent out that is delayed a random interval between 0 to
   MAX_COUNT seconds.

<span class="h2"><a class="selflink" id="section-13" href="#section-13">13</a>.  Acknowledgements</span>

   This document is the result of enormous effort by a large number of
   people including but not limited to:
   Alan Boshier, Babak Jahromi, Brandon Watson, Craig White, Dave
   Thaler, Holly Knight, Michel Guittet, Mike Zintel, Munil Shah, Paul
   Moore, Peter Ford, Pradeep Bahl, and Todd Fisher.

<span class="h2"><a class="selflink" id="section-14" href="#section-14">14</a>.  References</span>



<span class="grey">Goland et al.                                                [Page 17]</span></pre>
<hr class='noprint'/><!--NewPage--><pre class='newpage'><span id="page-18" ></span>
<span class="grey">INTERNET-DRAFT                 SSDP/V1               October 28, 1999</span>


   [<a id="ref-HTTPUDP">HTTPUDP</a>] Y. Y. Goland. Multicast and Unicast UDP HTTP Requests.
   Internet Draft - a work in progress, <a href="/doc/html/draft-goland-http-udp-00.txt">draft-goland-http-udp-00.txt</a>.

   [<a id="ref-GENA">GENA</a>] J. Cohen, S. Aggarwal, Y. Y. Goland. General Event
   Notification Architecture Base: Client to Arbiter. Internet Draft -
   a work in progress, <a href="/doc/html/draft-cohen-gena-client-00.txt">draft-cohen-gena-client-00.txt</a>.

   [<a id="ref-MAN">MAN</a>] H. Nielsen, P. Leach, S. Lawrence. Mandatory Extensions in
   HTTP. Internet Draft - a work in progress, <a href="/doc/html/draft-frystyk-http-extensions-03.txt">draft-frystyk-http-</a>
   <a href="/doc/html/draft-frystyk-http-extensions-03.txt">extensions-03.txt</a>.

   [<a id="ref-RFC2119">RFC2119</a>] S. Bradner. Key words for use in RFCs to Indicate
   Requirement Levels.  <a href="/doc/html/rfc2119">RFC 2119</a>, March 1997.

   [<a id="ref-RFC2365">RFC2365</a>] D. Meyer.  Administratively Scoped IP Multicast.  <a href="/doc/html/rfc2365">RFC</a>
   <a href="/doc/html/rfc2365">2365</a>, July 1998.

   [<a id="ref-RFC2396">RFC2396</a>] T. Berners-Lee, R. Fielding and L. Masinter.  Uniform
   Resource Identifiers (URI): Generic Syntax.  <a href="/doc/html/rfc2396">RFC 2396</a>, August 1998.

   [<a id="ref-RFC2518">RFC2518</a>] Y. Goland, E. Whitehead, A. Faizi, S. Carter, and D.
   Jensen. HTTP Extensions for Distributed Authoring û WEBDAV. <a href="/doc/html/rfc2518">RFC</a>
   <a href="/doc/html/rfc2518">2518</a>, February 1999.

   [<a id="ref-RFC2616">RFC2616</a>] R. Fielding, J. Gettys, J. C. Mogul, H. Frystyk, L.
   Masinter, P. Leach and T. Berners-Lee. Hypertext Transfer Protocol -
   HTTP/1.1. <a href="/doc/html/rfc2616">RFC 2616</a>, November 1998.

   [<a id="ref-DASL">DASL</a>] S. Reddy, D. Lowry, S. Reddy, R. Henderson, J. Davis, A.
   Babich. DAV Searching &amp; Locating. a work in progress - <a href="/doc/html/draft-ietf-dasl-protocol-00.txt">draft-ietf-</a>
   <a href="/doc/html/draft-ietf-dasl-protocol-00.txt">dasl-protocol-00.txt</a>.

<span class="h2"><a class="selflink" id="section-15" href="#section-15">15</a>.  Author&#x27;s Addresses</span>

      Yaron Y. Goland, Ting Cai, Paul Leach, Ye Gu
      Microsoft Corporation
      One Microsoft Way
      Redmond, WA 98052

      Email: {yarong, tingcai, paulle, yegu}@microsoft.com

      Shivaun Albright
      Hewlett-Packard Company
      Roseville, CA

      Email: SHIVAUN_ALBRIGHT@HP-Roseville-om2.om.hp.com

      This document will expire in April 2000.





Goland et al.                                                [Page 18]
</pre></div>
    </div>

            
        </div>
        
    
    <script>
        var legend_html = 'Color legend:<br> \
        <table> \
        <tr><td>Unknown:</td>                   <td><span class="bgwhite">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft:</td>                     <td><span class="bgred">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Informational:</td>             <td><span class="bgorange">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Experimental:</td>              <td><span class="bgyellow">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Best Common Practice:</td>      <td><span class="bgmagenta">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Proposed Standard:</td>         <td><span class="bgblue">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Draft Standard (old designation):</td> <td><span class="bgcyan">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Internet Standard:</td>         <td><span class="bggreen">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Historic:</td>                  <td><span class="bggrey">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        <tr><td>Obsolete:</td>                  <td><span class="bgbrown">&nbsp;&nbsp;&nbsp;&nbsp;</span></td></tr> \
        </table>';
        function showLegend() {
            var elem = document.getElementById('legend');
            elem.innerHTML = legend_html
            elem.style.visibility='visible';
        }
        function hideLegend() {
            var elem = document.getElementById('legend');
            elem.style.visibility='hidden';
            elem.innerHTML = "";
        }
    </script>

</body>
</html>